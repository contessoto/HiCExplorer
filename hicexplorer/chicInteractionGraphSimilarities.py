import argparse
import sys
import errno
import os
import math
from multiprocessing import Process, Queue
from scipy.sparse import coo_matrix, dia_matrix, lil_matrix, csr_matrix

import time
import logging
log = logging.getLogger(__name__)

import numpy as np
from scipy import stats
import h5py
import networkx as nx
from holoviews.plotting.util import process_cmap
import matplotlib.pyplot as plt
import tarfile

import io
import tarfile
from contextlib import closing
from pyvis.network import Network
import scipy.sparse as sp
from sklearn.cluster import SpectralClustering, KMeans, AgglomerativeClustering, Birch
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap

from sklearn.decomposition import PCA, SparsePCA
from sklearn.manifold import TSNE
import umap
from sparse_neighbors_search import MinHash
# from sparse_neighbors_search import MinHashClustering

import hicmatrix.HiCMatrix as hm
from intervaltree import IntervalTree, Interval

from hicexplorer import utilities
from hicexplorer._version import __version__
from hicexplorer.chicChangeInteractionGraph import readGraphFile
# from hicexplorer.utilities import convertNansToZeros

from .lib import Viewpoint


def parse_arguments(args=None):
    parser = argparse.ArgumentParser(add_help=False,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description="""
chicCreateInteractionGraph computes the network of a reference point with its regions of interest. To add a region to the graph, a second file containing the chromatin status and peak is required.
For each interaction it is checked if it is matching the position of a peak; moreover, the chromatin status is used.
"""
                                     )

    parserRequired = parser.add_argument_group('Required arguments')

    parserRequired.add_argument('--graphFile', '-gf',
                                help='path to the graph files. Please use only the graph as generated by chicCreateInteractionGraph',
                                required=True)

    # parserRequired.add_argument('--peakFile', '-tf',
    #                             help='Peak file containing the peaks and chromatin status based on ATAC-Seq data.'
    #                             )
    # parserRequired.add_argument('--referencePoints', '-rp', help='Reference point file. Needs to be in the format: \'chr 100\' for a '
    #                             'single reference point or \'chr 100 200\' for a reference region and with a single reference point per line',
    #                             required=True)

    parserOpt = parser.add_argument_group('Optional arguments')

    parserOpt.add_argument('--outFileName', '-o',
                           help='Output file for the graph file'
                           ' (Default: %(default)s).',
                           required=False,
                           default='interactionGraph.hdf5')
    parserOpt.add_argument('--plotsFileName', '-po',
                           help='Output tar.gz of the plotted graph files.'
                           ' (Default: %(default)s).',
                           required=False,
                           default='plotInteractionGraphs.tar.gz')
    parserOpt.add_argument('--outputFormat', '-format',
                           help='Output format of the plot'
                           ' (Default: %(default)s).',
                           required=False,
                           default='png')
    parserOpt.add_argument('--figuresize',
                           help='Fontsize in the plot for x and y axis.',
                           type=float,
                           nargs=2,
                           default=(15, 6),
                           metavar=('x-size', 'y-size'))
                            #    default='scatterPlot.eps')
    parserOpt.add_argument('--dpi',
                           help='The dpi of the scatter plot.',
                           required=False,
                           default=300,
                           type=int)
    parserOpt.add_argument('--threads', '-t',
                           help='Number of threads (uses the python multiprocessing module)'
                           ' (Default: %(default)s).',
                           required=False,
                           default=4,
                           type=int
                           )
    parserOpt.add_argument("--help", "-h", action="help",
                           help="show this help message and exit")
    parserOpt.add_argument('--version', action='version',
                           version='%(prog)s {}'.format(__version__))
    return parser



def main(args=None):
    args = parse_arguments().parse_args(args)
    # viewpointObj = Viewpoint()

    fileList = []
    # read hdf file
    graphOneHDF5Object = h5py.File(args.graphFile, 'r')
    # graphTwoHDF5Object = h5py.File(args.graphFiles[1], 'r')

    fileTypeOne = graphOneHDF5Object.attrs['type']
    # fileTypeTwo = graphTwoHDF5Object.attrs['type']

    graphOneHDF5Object.close()
    # graphTwoHDF5Object.close()

    if fileTypeOne != 'graph':
        log.error("Wring file type! Exit.")
        exit(1)
    
    csr_matrix_interaction_one, csr_matrix_state_one, peak_dict_one, reference_point_dict_one, peak_type_dict_one, \
    peak_dict_inverse_one, reference_point_dict_inverse_one, peak_type_dict_invers_one = readGraphFile(args.graphFile)
    # csr_matrix_interaction_two, csr_matrix_state_two, peak_dict_two, reference_point_dict_two, peak_type_dict_two, \
    # peak_dict_inverse_two, reference_point_dict_inverse_two, peak_type_dict_invers_two = readGraphFile(args.graphFiles[1])

    # csr_matrix_state_one, csr_matrix_state_two, reference_point_dict_one, reference_point_dict_two, reference_point_dict_inverse_one, reference_point_dict_inverse_two = equalizeGraphs(csr_matrix_state_one, csr_matrix_state_two, reference_point_dict_inverse_one, reference_point_dict_inverse_two)
   
    # compute PCA directly
    # compute UMAP
    # compute t-sne

    # compute k-nn 
    log.debug('COomputing minhash')
    hash_functions = 5000
    minHash_object = MinHash(n_neighbors=csr_matrix_interaction_one.shape[0], number_of_hash_functions=hash_functions, number_of_cores=args.threads,
                        shingle_size=0, fast=True, maxFeatures=int(max(csr_matrix_interaction_one.getnnz(1))), absolute_numbers=False)
    minHash_object.fit(csr_matrix_interaction_one)

    precomputed_graph = minHash_object.kneighbors_graph(mode='distance')
    precomputed_graph = np.nan_to_num(precomputed_graph)
    precomputed_graph.data[np.isinf(precomputed_graph.data)] = 0
        
    log.debug('COomputing pca')
    
    # compute and plot PCA
    # min(csr_matrix_interaction_one.shape) - 1
    pca = PCA(n_components=min(precomputed_graph.shape) - 1)
    pca_tranformed = pca.fit_transform(precomputed_graph.todense())
    plt.figure(figsize=(args.figuresize[0], args.figuresize[1]))
    plt.scatter(pca_tranformed[:, 0], pca_tranformed[:, 1])
    plt.tight_layout()
    plt.savefig('pca.pdf', dpi=args.dpi)
    plt.close()